name: üõ°Ô∏è Medium Cybersecurity Writeups Aggregator

on:
  # Optimized scheduling for maximum efficiency
  schedule:
    - cron: '0 */2 * * *'        # Every 2 hours
    - cron: '*/30 9-17 * * 1-5'  # Every 30 minutes during business hours (weekdays)
    - cron: '0 */6 * * 0,6'      # Every 6 hours on weekends
  
  # Manual trigger for testing and on-demand updates
  workflow_dispatch:
    inputs:
      force_update:
        description: 'Force update even if no new content'
        required: false
        default: 'false'
        type: boolean
      debug_mode:
        description: 'Enable debug output'
        required: false
        default: 'false'
        type: boolean
      max_feeds:
        description: 'Maximum number of feeds to process (for testing)'
        required: false
        default: '0'
        type: number
  
  # Trigger on main branch changes
  push:
    branches:
      - main
    paths:
      - 'main.go'
      - '.github/workflows/*.yml'
      - 'go.mod'
      - 'go.sum'

# Enhanced permissions for security and functionality
permissions:
  contents: write
  issues: write
  pull-requests: read
  actions: read
  pages: write
  id-token: write

# Global environment variables
env:
  GO_VERSION: '1.23.4'
  TIMEZONE: 'UTC'
  MAX_RETRIES: 3
  RATE_LIMIT_DELAY: 5
  REQUEST_TIMEOUT: 30

jobs:
  # Job 1: Setup and validate environment
  setup:
    name: üîß Setup Environment
    runs-on: ubuntu-latest
    outputs:
      should_proceed: ${{ steps.validate.outputs.should_proceed }}
      go_mod_exists: ${{ steps.check_files.outputs.go_mod_exists }}
      
    steps:
      - name: üìã Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 1
      
      - name: üîç Check required files
        id: check_files
        run: |
          echo "üîç Checking for required files..."
          
          # Check if main.go exists
          if [ ! -f "main.go" ]; then
            echo "‚ùå main.go not found!"
            echo "should_proceed=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          echo "‚úÖ main.go found"
          
          # Check if go.mod exists
          if [ -f "go.mod" ]; then
            echo "‚úÖ go.mod found"
            echo "go_mod_exists=true" >> $GITHUB_OUTPUT
          else
            echo "‚ö†Ô∏è go.mod not found - will create it"
            echo "go_mod_exists=false" >> $GITHUB_OUTPUT
          fi
      
      - name: ‚úÖ Validate setup
        id: validate
        run: |
          echo "‚úÖ All checks passed"
          echo "should_proceed=true" >> $GITHUB_OUTPUT
          echo "üìÖ Workflow triggered at: $(date -u)"
          echo "üîÑ Trigger event: ${{ github.event_name }}"

  # Job 2: Initialize Go module if needed
  init-go-module:
    name: üì¶ Initialize Go Module
    runs-on: ubuntu-latest
    needs: setup
    if: needs.setup.outputs.should_proceed == 'true' && needs.setup.outputs.go_mod_exists == 'false'
    
    steps:
      - name: üìã Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
      
      - name: üîß Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
      
      - name: üì¶ Initialize Go module
        run: |
          echo "üì¶ Initializing Go module..."
          go mod init medium-writeups-aggregator
          echo "‚úÖ Go module initialized"
          
          # Add any required dependencies based on main.go imports
          echo "üì• Adding dependencies..."
          go mod tidy
          echo "‚úÖ Dependencies resolved"
      
      - name: üì§ Commit go.mod files
        run: |
          git config --global user.name 'GitHub Actions Bot'
          git config --global user.email 'actions@users.noreply.github.com'
          
          git add go.mod
          if [ -f "go.sum" ]; then
            git add go.sum
          fi
          
          if ! git diff --cached --exit-code > /dev/null; then
            git commit -m "üì¶ Initialize Go module

            - Add go.mod file
            - Set up proper dependency management
            - Auto-generated by GitHub Actions"
            
            git push origin main
            echo "‚úÖ Go module files committed and pushed"
          else
            echo "‚ÑπÔ∏è No changes to commit"
          fi

  # Job 3: Build and test
  build-test:
    name: üèóÔ∏è Build & Test
    runs-on: ubuntu-latest
    needs: [setup, init-go-module]
    if: always() && needs.setup.outputs.should_proceed == 'true'
    
    steps:
      - name: üìã Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main  # Ensure we get latest changes including go.mod
      
      - name: üîß Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      
      - name: üì¶ Ensure Go module exists
        run: |
          if [ ! -f "go.mod" ]; then
            echo "üì¶ Creating go.mod..."
            go mod init medium-writeups-aggregator
          fi
          
          echo "üì• Downloading dependencies..."
          go mod tidy
          go mod download
          echo "‚úÖ Dependencies ready"
      
      - name: üß™ Build application
        run: |
          echo "üî® Building application..."
          go build -v -o aggregator ./main.go
          echo "‚úÖ Build successful"
          
          # Test if the binary works
          echo "üß™ Testing binary..."
          ./aggregator --help 2>/dev/null || echo "‚ÑπÔ∏è Binary created (help flag not implemented)"
          echo "‚úÖ Binary test completed"
      
      - name: üîç Run code analysis
        run: |
          echo "üîç Running go vet..."
          go vet ./...
          echo "‚úÖ Code analysis passed"

  # Job 4: Main aggregation job with enhanced rate limiting
  aggregate:
    name: üì∞ Aggregate Posts
    runs-on: ubuntu-latest
    needs: [setup, build-test]
    if: needs.setup.outputs.should_proceed == 'true'
    timeout-minutes: 45
    
    steps:
      - name: üìã Checkout repository
        uses: actions/checkout@v4
        with:
          token: ${{ secrets.GITHUB_TOKEN }}
          ref: main  # Get latest version with go.mod
      
      - name: üîß Setup Go
        uses: actions/setup-go@v5
        with:
          go-version: ${{ env.GO_VERSION }}
          cache: true
      
      - name: üåç Configure environment
        run: |
          sudo timedatectl set-timezone ${{ env.TIMEZONE }}
          echo "üåç Timezone: $(timedatectl show --property=Timezone --value)"
          echo "üìÖ Current time: $(date)"
          echo "üîÑ Max retries: ${{ env.MAX_RETRIES }}"
          echo "‚è±Ô∏è Rate limit delay: ${{ env.RATE_LIMIT_DELAY }}s"
      
      - name: üì¶ Prepare Go module
        run: |
          if [ ! -f "go.mod" ]; then
            echo "üì¶ Creating go.mod..."
            go mod init medium-writeups-aggregator
          fi
          go mod tidy
          echo "‚úÖ Go module ready"
      
      - name: üíæ Backup current README
        run: |
          if [ -f README.md ]; then
            cp README.md README.md.backup
            echo "‚úÖ Current README backed up"
          else
            echo "‚ÑπÔ∏è No existing README to backup"
            touch README.md.backup
          fi
      
      - name: üöÄ Run aggregator with enhanced error handling
        id: aggregate
        run: |
          echo "üöÄ Starting Medium cybersecurity posts aggregation..."
          
          # Create a wrapper script for better error handling
          cat > run_aggregator.sh << 'EOF'
          #!/bin/bash
          set -euo pipefail
          
          RETRY_COUNT=0
          MAX_RETRIES=$1
          RATE_LIMIT_DELAY=$2
          DEBUG_MODE=$3
          MAX_FEEDS=$4
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "üîÑ Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES"
            
            # Set environment variables for the Go program
            export RATE_LIMIT_DELAY="$RATE_LIMIT_DELAY"
            export DEBUG_MODE="$DEBUG_MODE"
            export MAX_FEEDS="$MAX_FEEDS"
            
            if timeout 2400 go run main.go > NEW-README.md 2>&1; then
              echo "‚úÖ Aggregation completed successfully"
              
              # Validate output
              if [ -s NEW-README.md ]; then
                WORD_COUNT=$(wc -w < NEW-README.md)
                if [ $WORD_COUNT -gt 50 ]; then
                  echo "‚úÖ Output validation passed ($WORD_COUNT words)"
                  exit 0
                else
                  echo "‚ö†Ô∏è Output seems too small ($WORD_COUNT words)"
                fi
              else
                echo "‚ùå Output file is empty"
              fi
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
            if [ $RETRY_COUNT -lt $MAX_RETRIES ]; then
              DELAY=$((RATE_LIMIT_DELAY * RETRY_COUNT * 2))  # Exponential backoff
              echo "‚è≥ Rate limited - waiting ${DELAY}s before retry..."
              sleep $DELAY
            fi
          done
          
          echo "‚ùå All retry attempts failed"
          exit 1
          EOF
          
          chmod +x run_aggregator.sh
          
          # Run with parameters
          DEBUG_MODE="${{ github.event.inputs.debug_mode || 'false' }}"
          MAX_FEEDS="${{ github.event.inputs.max_feeds || '0' }}"
          
          if ./run_aggregator.sh "${{ env.MAX_RETRIES }}" "${{ env.RATE_LIMIT_DELAY }}" "$DEBUG_MODE" "$MAX_FEEDS"; then
            echo "success=true" >> $GITHUB_OUTPUT
          else
            echo "success=false" >> $GITHUB_OUTPUT
            echo "‚ùå Aggregation failed after all retries"
            
            # Show some debug info
            echo "üìä Debug information:"
            echo "- Go version: $(go version)"
            echo "- Available memory: $(free -h)"
            echo "- Disk space: $(df -h .)"
            
            exit 1
          fi
      
      - name: üìä Analyze results
        id: analyze
        if: steps.aggregate.outputs.success == 'true'
        run: |
          echo "üìä Analyzing aggregation results..."
          
          if [ ! -f NEW-README.md ] || [ ! -s NEW-README.md ]; then
            echo "‚ùå Output file missing or empty"
            echo "has_content=false" >> $GITHUB_OUTPUT
            exit 1
          fi
          
          # Extract statistics
          WORD_COUNT=$(wc -w < NEW-README.md)
          LINE_COUNT=$(wc -l < NEW-README.md)
          SIZE=$(du -h NEW-README.md | cut -f1)
          
          echo "üìÑ Generated file stats:"
          echo "  - Lines: $LINE_COUNT"
          echo "  - Words: $WORD_COUNT"
          echo "  - Size: $SIZE"
          
          # Extract post statistics
          TOTAL_POSTS=$(grep -o "Total Posts.*[0-9]\+" NEW-README.md | grep -o "[0-9]\+" | head -1 || echo "0")
          NEW_POSTS=$(grep -o "New Posts.*[0-9]\+" NEW-README.md | grep -o "[0-9]\+" | head -1 || echo "0")
          TODAY_POSTS=$(grep -o "Today's Posts.*[0-9]\+" NEW-README.md | grep -o "[0-9]\+" | head -1 || echo "0")
          
          echo "üìà Content statistics:"
          echo "  - Total posts: $TOTAL_POSTS"
          echo "  - New posts: $NEW_POSTS"
          echo "  - Today's posts: $TODAY_POSTS"
          
          # Validate minimum content
          if [ $WORD_COUNT -lt 100 ] || [ $TOTAL_POSTS -eq 0 ]; then
            echo "‚ö†Ô∏è Content validation failed"
            echo "has_content=false" >> $GITHUB_OUTPUT
          else
            echo "‚úÖ Content validation passed"
            echo "has_content=true" >> $GITHUB_OUTPUT
          fi
          
          # Save statistics
          echo "total_posts=$TOTAL_POSTS" >> $GITHUB_OUTPUT
          echo "new_posts=$NEW_POSTS" >> $GITHUB_OUTPUT
          echo "today_posts=$TODAY_POSTS" >> $GITHUB_OUTPUT
          echo "word_count=$WORD_COUNT" >> $GITHUB_OUTPUT
      
      - name: üîç Compare with previous version
        id: compare
        if: steps.analyze.outputs.has_content == 'true'
        run: |
          echo "üîç Comparing with previous version..."
          
          FORCE_UPDATE="${{ github.event.inputs.force_update }}"
          HAS_CHANGES=false
          
          if [ ! -s README.md.backup ]; then
            echo "‚ÑπÔ∏è No previous content - treating as new"
            HAS_CHANGES=true
          elif [ "$FORCE_UPDATE" = "true" ]; then
            echo "üîÑ Force update requested"
            HAS_CHANGES=true
          else
            # Compare significant content (exclude timestamps and small changes)
            if ! diff -q \
              <(grep -v -E "(Last Updated|Updated List|Generated by|Auto-updated)" README.md.backup | head -20) \
              <(grep -v -E "(Last Updated|Updated List|Generated by|Auto-updated)" NEW-README.md | head -20) \
              > /dev/null 2>&1; then
              echo "üìù Significant content changes detected"
              HAS_CHANGES=true
            else
              # Check if we have new posts
              NEW_COUNT="${{ steps.analyze.outputs.new_posts }}"
              if [ "$NEW_COUNT" -gt 0 ]; then
                echo "üìù New posts detected ($NEW_COUNT new posts)"
                HAS_CHANGES=true
              else
                echo "üìã No significant changes"
                HAS_CHANGES=false
              fi
            fi
          fi
          
          echo "has_changes=$HAS_CHANGES" >> $GITHUB_OUTPUT
          echo "üìä Change detection result: $HAS_CHANGES"
      
      - name: üìù Update README
        if: steps.compare.outputs.has_changes == 'true'
        run: |
          echo "üìù Updating README.md..."
          
          # Clean up ANSI color codes from the output
          sed -i 's/\x1b\[[0-9;]*m//g' NEW-README.md
          
          # Replace README
          rm -f README.md
          mv NEW-README.md README.md
          echo "‚úÖ README.md updated successfully"
      
      - name: üì§ Commit and push changes
        if: steps.compare.outputs.has_changes == 'true'
        id: commit
        run: |
          echo "üì§ Preparing to commit changes..."
          
          # Configure Git
          git config --global user.name 'Medium Writeups Bot'
          git config --global user.email 'actions+medium-bot@users.noreply.github.com'
          
          # Add changes
          git add README.md
          if [ -f index.html ]; then
            git add index.html
          fi
          
          # Check for changes
          if git diff --cached --exit-code > /dev/null; then
            echo "‚ÑπÔ∏è No changes to commit"
            echo "committed=false" >> $GITHUB_OUTPUT
          else
            # Create commit message
            UTC_DATE=$(date -u +'%a %b %d %H:%M:%S UTC %Y')
            IST_DATE=$(TZ='Asia/Kolkata' date +'%a %b %d %H:%M:%S IST %Y')
            
            COMMIT_MSG="üîÑ Update Medium Cybersecurity Posts - $IST_DATE

            üìä Statistics:
            ‚Ä¢ Total Posts: ${{ steps.analyze.outputs.total_posts }}
            ‚Ä¢ New Posts: ${{ steps.analyze.outputs.new_posts }}
            ‚Ä¢ Today's Posts: ${{ steps.analyze.outputs.today_posts }}
            ‚Ä¢ Content Size: ${{ steps.analyze.outputs.word_count }} words
            
            ü§ñ Auto-generated by GitHub Actions
            üìÖ UTC: $UTC_DATE
            üèÉ Run: ${{ github.run_number }}
            
            Co-authored-by: Medium RSS Bot <actions@users.noreply.github.com>"
            
            # Commit and push with retry
            git commit -m "$COMMIT_MSG"
            
            PUSH_ATTEMPTS=0
            while [ $PUSH_ATTEMPTS -lt 3 ]; do
              if git push origin main; then
                echo "‚úÖ Successfully pushed changes"
                echo "committed=true" >> $GITHUB_OUTPUT
                break
              else
                PUSH_ATTEMPTS=$((PUSH_ATTEMPTS + 1))
                echo "‚ö†Ô∏è Push attempt $PUSH_ATTEMPTS failed"
                if [ $PUSH_ATTEMPTS -lt 3 ]; then
                  sleep 10
                  git pull --rebase origin main || true
                fi
              fi
            done
            
            if [ $PUSH_ATTEMPTS -eq 3 ]; then
              echo "‚ùå Failed to push after 3 attempts"
              exit 1
            fi
          fi
      
      - name: üßπ Cleanup
        if: always()
        run: |
          echo "üßπ Cleaning up temporary files..."
          rm -f NEW-README.md README.md.backup run_aggregator.sh
          echo "‚úÖ Cleanup completed"
      
      - name: üìã Generate summary
        if: always()
        run: |
          echo "# üõ°Ô∏è Medium Cybersecurity Aggregation Summary" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          echo "## üìä Execution Details" >> $GITHUB_STEP_SUMMARY
          echo "- **Timestamp**: $(date -u)" >> $GITHUB_STEP_SUMMARY
          echo "- **Trigger**: ${{ github.event_name }}" >> $GITHUB_STEP_SUMMARY
          echo "- **Run**: #${{ github.run_number }}" >> $GITHUB_STEP_SUMMARY
          echo "" >> $GITHUB_STEP_SUMMARY
          
          if [ "${{ steps.analyze.outputs.has_content }}" = "true" ]; then
            echo "## üìà Content Statistics" >> $GITHUB_STEP_SUMMARY
            echo "- **Total Posts**: ${{ steps.analyze.outputs.total_posts }}" >> $GITHUB_STEP_SUMMARY
            echo "- **New Posts**: ${{ steps.analyze.outputs.new_posts }}" >> $GITHUB_STEP_SUMMARY
            echo "- **Today's Posts**: ${{ steps.analyze.outputs.today_posts }}" >> $GITHUB_STEP_SUMMARY
          fi
          
          echo "## ‚úÖ Results" >> $GITHUB_STEP_SUMMARY
          if [ "${{ steps.compare.outputs.has_changes }}" = "true" ]; then
            echo "- üîÑ **README Updated**: Yes" >> $GITHUB_STEP_SUMMARY
            echo "- üìù **Committed**: ${{ steps.commit.outputs.committed || 'false' }}" >> $GITHUB_STEP_SUMMARY
          else
            echo "- ‚è≠Ô∏è **README Updated**: No significant changes" >> $GITHUB_STEP_SUMMARY
          fi

  # Job 5: Deploy to GitHub Pages
  deploy-pages:
    name: üåê Deploy to GitHub Pages
    runs-on: ubuntu-latest
    needs: [aggregate]
    if: needs.aggregate.result == 'success'
    
    # Grant GITHUB_TOKEN the permissions required to make a Pages deployment
    permissions:
      pages: write      # to deploy to Pages
      id-token: write   # to verify the deployment originates from an appropriate source
      contents: read    # to read the repository contents
    
    # Deploy to the github-pages environment
    environment:
      name: github-pages
      url: ${{ steps.deployment.outputs.page_url }}
    
    steps:
      - name: üìã Checkout repository
        uses: actions/checkout@v4
        with:
          ref: main
      
      - name: üîç Check for GitHub Pages files
        id: check_pages
        run: |
          if [ -f "index.html" ]; then
            echo "‚úÖ index.html found - deploying to GitHub Pages"
            echo "has_pages=true" >> $GITHUB_OUTPUT
          else
            echo "‚ÑπÔ∏è No index.html found - skipping Pages deployment"
            echo "has_pages=false" >> $GITHUB_OUTPUT
          fi
      
      - name: üîß Setup Pages
        if: steps.check_pages.outputs.has_pages == 'true'
        uses: actions/configure-pages@v4
      
      - name: üì¶ Upload Pages artifact
        if: steps.check_pages.outputs.has_pages == 'true'
        uses: actions/upload-pages-artifact@v3
        with:
          path: '.'
      
      - name: üöÄ Deploy to GitHub Pages
        if: steps.check_pages.outputs.has_pages == 'true'
        id: deployment
        uses: actions/deploy-pages@v4

  # Job 6: Handle failures and notifications
  handle-failure:
    name: üö® Handle Failures
    runs-on: ubuntu-latest
    needs: [aggregate]
    if: always() && needs.aggregate.result == 'failure'
    
    steps:
      - name: üìä Failure analysis
        run: |
          echo "üö® Workflow failed - analyzing..."
          echo "- Aggregate job result: ${{ needs.aggregate.result }}"
          echo "- Failure time: $(date -u)"
      
      - name: üìù Create failure issue
        uses: actions/github-script@v7
        with:
          script: |
            const title = `üö® Aggregation Failed - ${new Date().toISOString().split('T')[0]}`;
            const body = `
            ## üö® Medium Writeups Aggregation Failed
            
            **Failure Details:**
            - **Time**: ${new Date().toISOString()}
            - **Run**: [${{ github.run_number }}](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            - **Trigger**: ${{ github.event_name }}
            - **Branch**: ${{ github.ref_name }}
            
            **Possible Causes:**
            - Rate limiting from Medium RSS feeds (HTTP 429)
            - Network connectivity issues
            - Go module or dependency problems
            - Application logic errors
            - Compilation errors in main.go
            
            **Debugging Steps:**
            1. üîç [Check the workflow logs](${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }})
            2. ‚è≥ Wait for rate limits to reset (usually 2-4 hours)
            3. üîÑ Try manually triggering the workflow with reduced max_feeds (e.g., 20)
            4. üîß Check if main.go compiles locally
            5. üìù Review recent changes to main.go or workflow files
            
            **Quick Fixes:**
            - If it's a rate limiting issue, the next scheduled run should work
            - If it's a compilation error, check the main.go file structure
            - If it's a dependency issue, the go.mod file may need updating
            
            ---
            *Auto-generated by GitHub Actions*
            `;
            
            // Check if a similar issue already exists
            const existingIssues = await github.rest.issues.listForRepo({
              owner: context.repo.owner,
              repo: context.repo.repo,
              labels: 'workflow-failure',
              state: 'open'
            });
            
            if (existingIssues.data.length === 0) {
              await github.rest.issues.create({
                owner: context.repo.owner,
                repo: context.repo.repo,
                title: title,
                body: body,
                labels: ['bug', 'workflow-failure', 'automated']
              });
              console.log('üìù Failure issue created');
            } else {
              console.log('‚ÑπÔ∏è Existing failure issue found - not creating duplicate');
            }